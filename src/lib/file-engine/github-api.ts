/**
import { BRAND_NAME } from '@/lib/brand'

 * FILE ENGINE - GitHub API Integration
 * 
 * Handles all GitHub API calls for:
 * - Repository creation
 * - File pushing/committing
 * - Branch management
 */

// ============================================
// TYPES
// ============================================

export interface GitHubRepo {
  id: number;
  name: string;
  full_name: string;
  html_url: string;
  clone_url: string;
  default_branch: string;
  private: boolean;
}

export interface GitHubFile {
  path: string;
  content: string;
}

export interface CreateRepoResult {
  success: boolean;
  repo?: GitHubRepo;
  error?: string;
}

export interface PushResult {
  success: boolean;
  commitSha?: string;
  commitUrl?: string;
  error?: string;
}

export interface GitHubOptions {
  token?: string;
  owner?: string;
}

// ============================================
// CONFIGURATION
// ============================================

const GITHUB_API_BASE = 'https://api.github.com';

// Get GitHub token - admin uses env var, users use encrypted stored token
export function getGitHubToken(userToken?: string): string | null {
  if (userToken) return userToken;
  return process.env.GITHUB_TOKEN || process.env.ADMIN_GITHUB_TOKEN || null;
}

// Get default GitHub username
export function getGitHubUsername(): string | null {
  return process.env.GITHUB_USERNAME || null;
}

// ============================================
// API HELPERS
// ============================================

async function githubFetch(
  endpoint: string,
  options: RequestInit & { token?: string } = {}
): Promise<Response> {
  const { token, ...fetchOptions } = options;
  const authToken = getGitHubToken(token);
  
  if (!authToken) {
    throw new Error('GitHub token not configured');
  }

  return fetch(`${GITHUB_API_BASE}${endpoint}`, {
    ...fetchOptions,
    headers: {
      'Authorization': `token ${authToken}`,
      'Accept': 'application/vnd.github.v3+json',
      'Content-Type': 'application/json',
      ...fetchOptions.headers
    }
  });
}

// ============================================
// CORE FUNCTIONS
// ============================================

/**
 * Check if a repository exists
 */
export async function checkRepoExists(
  owner: string,
  repoName: string,
  options: GitHubOptions = {}
): Promise<boolean> {
  try {
    const response = await githubFetch(`/repos/${owner}/${repoName}`, {
      method: 'GET',
      token: options.token
    });
    return response.ok;
  } catch {
    return false;
  }
}

/**
 * Create a new GitHub repository
 */
export async function createRepository(
  name: string,
  options: {
    description?: string;
    private?: boolean;
    autoInit?: boolean;
    token?: string;
  } = {}
): Promise<CreateRepoResult> {
  const {
    description = `Generated by ${BRAND_NAME}`,
    private: isPrivate = false,
    autoInit = true,
    token
  } = options;

  try {
    const response = await githubFetch('/user/repos', {
      method: 'POST',
      token,
      body: JSON.stringify({
        name: name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, ''),
        description,
        private: isPrivate,
        auto_init: autoInit
      })
    });

    if (!response.ok) {
      const error = await response.json();
      return {
        success: false,
        error: error.message || 'Failed to create repository'
      };
    }

    const repo = await response.json();
    return { success: true, repo };
    
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Get the default branch ref SHA
 */
async function getDefaultBranchSha(
  owner: string,
  repo: string,
  options: GitHubOptions = {}
): Promise<{ sha: string; branch: string } | null> {
  // Try 'main' first
  try {
    const mainResponse = await githubFetch(`/repos/${owner}/${repo}/git/ref/heads/main`, {
      token: options.token
    });
    
    if (mainResponse.ok) {
      const data = await mainResponse.json();
      return { sha: data.object.sha, branch: 'main' };
    }
  } catch { /* try next branch */ }

  // Try 'master'
  try {
    const masterResponse = await githubFetch(`/repos/${owner}/${repo}/git/ref/heads/master`, {
      token: options.token
    });
    
    if (masterResponse.ok) {
      const data = await masterResponse.json();
      return { sha: data.object.sha, branch: 'master' };
    }
  } catch { /* no default branch found */ }

  return null;
}

/**
 * Push files to a GitHub repository
 */
export async function pushFiles(
  owner: string,
  repo: string,
  files: GitHubFile[],
  options: {
    branch?: string;
    commitMessage?: string;
    token?: string;
  } = {}
): Promise<PushResult> {
  const {
    commitMessage = `Update from ${BRAND_NAME}`,
    token
  } = options;

  try {
    // Get the default branch SHA
    const branchInfo = await getDefaultBranchSha(owner, repo, { token });
    
    if (!branchInfo) {
      return {
        success: false,
        error: 'Could not find default branch (main or master)'
      };
    }

    const { sha: baseSha, branch } = branchInfo;

    // Create blobs for each file
    const blobs = await Promise.all(
      files.map(async (file) => {
        const blobResponse = await githubFetch(`/repos/${owner}/${repo}/git/blobs`, {
          method: 'POST',
          token,
          body: JSON.stringify({
            content: Buffer.from(file.content).toString('base64'),
            encoding: 'base64'
          })
        });
        
        if (!blobResponse.ok) {
          throw new Error(`Failed to create blob for ${file.path}`);
        }
        
        const blobData = await blobResponse.json();
        return {
          path: file.path.startsWith('/') ? file.path.slice(1) : file.path,
          mode: '100644' as const,
          type: 'blob' as const,
          sha: blobData.sha
        };
      })
    );

    // Create a new tree
    const treeResponse = await githubFetch(`/repos/${owner}/${repo}/git/trees`, {
      method: 'POST',
      token,
      body: JSON.stringify({
        base_tree: baseSha,
        tree: blobs
      })
    });

    if (!treeResponse.ok) {
      const error = await treeResponse.json();
      return { success: false, error: error.message || 'Failed to create tree' };
    }

    const treeData = await treeResponse.json();

    // Create a new commit
    const commitResponse = await githubFetch(`/repos/${owner}/${repo}/git/commits`, {
      method: 'POST',
      token,
      body: JSON.stringify({
        message: commitMessage,
        tree: treeData.sha,
        parents: [baseSha]
      })
    });

    if (!commitResponse.ok) {
      const error = await commitResponse.json();
      return { success: false, error: error.message || 'Failed to create commit' };
    }

    const commitData = await commitResponse.json();

    // Update the reference
    const refResponse = await githubFetch(`/repos/${owner}/${repo}/git/refs/heads/${branch}`, {
      method: 'PATCH',
      token,
      body: JSON.stringify({
        sha: commitData.sha,
        force: true
      })
    });

    if (!refResponse.ok) {
      const error = await refResponse.json();
      return { success: false, error: error.message || 'Failed to update reference' };
    }

    return {
      success: true,
      commitSha: commitData.sha,
      commitUrl: commitData.html_url || `https://github.com/${owner}/${repo}/commit/${commitData.sha}`
    };

  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Create repo and push files in one operation
 */
export async function createRepoAndPush(
  repoName: string,
  files: GitHubFile[],
  options: {
    description?: string;
    private?: boolean;
    commitMessage?: string;
    token?: string;
  } = {}
): Promise<{
  success: boolean;
  repoUrl?: string;
  commitSha?: string;
  error?: string;
}> {
  const { token, ...createOptions } = options;

  // Create the repository
  const createResult = await createRepository(repoName, {
    ...createOptions,
    autoInit: true,
    token
  });

  if (!createResult.success || !createResult.repo) {
    return {
      success: false,
      error: createResult.error || 'Failed to create repository'
    };
  }

  // Wait a moment for GitHub to initialize the repo
  await new Promise(resolve => setTimeout(resolve, 2000));

  // Get the owner from the repo response
  const [owner, repo] = createResult.repo.full_name.split('/');

  // Push files
  const pushResult = await pushFiles(owner, repo, files, {
    commitMessage: options.commitMessage || `Initial commit from ${BRAND_NAME}`,
    token
  });

  if (!pushResult.success) {
    return {
      success: false,
      repoUrl: createResult.repo.html_url,
      error: pushResult.error || 'Failed to push files'
    };
  }

  return {
    success: true,
    repoUrl: createResult.repo.html_url,
    commitSha: pushResult.commitSha
  };
}

/**
 * Delete a repository (for cleanup/testing)
 */
export async function deleteRepository(
  owner: string,
  repo: string,
  options: GitHubOptions = {}
): Promise<boolean> {
  try {
    const response = await githubFetch(`/repos/${owner}/${repo}`, {
      method: 'DELETE',
      token: options.token
    });
    return response.ok || response.status === 204;
  } catch {
    return false;
  }
}

/**
 * Get current user info
 */
export async function getCurrentUser(options: GitHubOptions = {}): Promise<{
  login: string;
  name?: string;
  email?: string;
} | null> {
  try {
    const response = await githubFetch('/user', { token: options.token });
    if (!response.ok) return null;
    return await response.json();
  } catch {
    return null;
  }
}

// ============================================
// EXPORTS
// ============================================

export {
  GITHUB_API_BASE
};
