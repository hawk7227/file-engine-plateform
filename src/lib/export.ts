// =====================================================
// FILE ENGINE - CODE EXPORT SYSTEM
// Download generated code as files or ZIP
// =====================================================

import JSZip from 'jszip'
import { BRAND_NAME } from '@/lib/brand'

export interface ExportFile {
  path: string
  content: string
  language?: string
}

// =====================================================
// GENERATE SINGLE FILE DOWNLOAD
// =====================================================

export function downloadSingleFile(file: ExportFile, filename?: string): void {
  const blob = new Blob([file.content], { type: 'text/plain;charset=utf-8' })
  const url = URL.createObjectURL(blob)
  
  const a = document.createElement('a')
  a.href = url
  a.download = filename || file.path.split('/').pop() || 'file.txt'
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}

// =====================================================
// GENERATE ZIP DOWNLOAD
// =====================================================

export async function downloadAsZip(
  files: ExportFile[],
  projectName: string = 'file-engine-export'
): Promise<void> {
  const zip = new JSZip()
  
  // Add each file to the zip
  for (const file of files) {
    // Remove leading slash if present
    const path = file.path.startsWith('/') ? file.path.slice(1) : file.path
    zip.file(path, file.content)
  }
  
  // Add a README
  const readme = generateReadme(files, projectName)
  zip.file('README.md', readme)
  
  // Add package.json if not present and we have TypeScript/JavaScript files
  const hasPackageJson = files.some(f => f.path.includes('package.json'))
  const hasJsTs = files.some(f => 
    f.path.endsWith('.ts') || 
    f.path.endsWith('.tsx') || 
    f.path.endsWith('.js') || 
    f.path.endsWith('.jsx')
  )
  
  if (!hasPackageJson && hasJsTs) {
    const packageJson = generatePackageJson(files, projectName)
    zip.file('package.json', packageJson)
  }
  
  // Generate and download
  const blob = await zip.generateAsync({ type: 'blob' })
  const url = URL.createObjectURL(blob)
  
  const a = document.createElement('a')
  a.href = url
  a.download = `${projectName}.zip`
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}

// =====================================================
// GENERATE README
// =====================================================

function generateReadme(files: ExportFile[], projectName: string): string {
  const fileList = files.map(f => `- \`${f.path}\``).join('\n')
  
  return `# ${projectName}

Generated by [${BRAND_NAME}](https://fileengine.dev) - AI-Powered Code Generation

## Files

${fileList}

## Getting Started

\`\`\`bash
# Install dependencies
npm install

# Run development server
npm run dev
\`\`\`

## Generated with ${BRAND_NAME}

This code was generated using ${BRAND_NAME}'s AI-powered code generation platform with 10-layer validation.

- ✓ Syntax validated
- ✓ Type checked
- ✓ Best practices applied
- ✓ Security scanned

Learn more at [fileengine.dev](https://fileengine.dev)
`
}

// =====================================================
// GENERATE PACKAGE.JSON
// =====================================================

function generatePackageJson(files: ExportFile[], projectName: string): string {
  const hasReact = files.some(f => 
    f.content.includes('import React') || 
    f.content.includes("from 'react'") ||
    f.path.endsWith('.tsx') ||
    f.path.endsWith('.jsx')
  )
  
  const hasNext = files.some(f => 
    f.content.includes("from 'next") ||
    f.path.includes('/app/') ||
    f.path.includes('/pages/')
  )
  
  const hasTailwind = files.some(f => 
    f.content.includes('className=') ||
    f.content.includes('tailwind')
  )
  
  const dependencies: Record<string, string> = {}
  const devDependencies: Record<string, string> = {
    'typescript': '^5.0.0',
    '@types/node': '^20.0.0'
  }
  
  if (hasNext) {
    dependencies['next'] = '^14.0.0'
    dependencies['react'] = '^18.0.0'
    dependencies['react-dom'] = '^18.0.0'
    devDependencies['@types/react'] = '^18.0.0'
    devDependencies['@types/react-dom'] = '^18.0.0'
  } else if (hasReact) {
    dependencies['react'] = '^18.0.0'
    dependencies['react-dom'] = '^18.0.0'
    devDependencies['@types/react'] = '^18.0.0'
    devDependencies['@types/react-dom'] = '^18.0.0'
  }
  
  if (hasTailwind) {
    devDependencies['tailwindcss'] = '^3.4.0'
    devDependencies['postcss'] = '^8.4.0'
    devDependencies['autoprefixer'] = '^10.4.0'
  }
  
  const scripts: Record<string, string> = {}
  
  if (hasNext) {
    scripts['dev'] = 'next dev'
    scripts['build'] = 'next build'
    scripts['start'] = 'next start'
  } else {
    scripts['build'] = 'tsc'
  }
  
  return JSON.stringify({
    name: projectName.toLowerCase().replace(/\s+/g, '-'),
    version: '1.0.0',
    private: true,
    scripts,
    dependencies,
    devDependencies
  }, null, 2)
}

// =====================================================
// COPY TO CLIPBOARD
// =====================================================

export async function copyToClipboard(content: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(content)
    return true
  } catch (err) {
    // Fallback for older browsers
    const textArea = document.createElement('textarea')
    textArea.value = content
    textArea.style.position = 'fixed'
    textArea.style.left = '-999999px'
    document.body.appendChild(textArea)
    textArea.select()
    
    try {
      document.execCommand('copy')
      document.body.removeChild(textArea)
      return true
    } catch (e) {
      document.body.removeChild(textArea)
      return false
    }
  }
}

// =====================================================
// COPY ALL FILES AS FORMATTED TEXT
// =====================================================

export async function copyAllFilesAsText(files: ExportFile[]): Promise<boolean> {
  const text = files.map(file => {
    const ext = file.path.split('.').pop() || ''
    return `// File: ${file.path}\n\`\`\`${ext}\n${file.content}\n\`\`\`\n`
  }).join('\n')
  
  return copyToClipboard(text)
}

// =====================================================
// GENERATE GITHUB GIST CONTENT
// =====================================================

export function generateGistContent(files: ExportFile[]): Record<string, { content: string }> {
  const gistFiles: Record<string, { content: string }> = {}
  
  for (const file of files) {
    // Gist doesn't support nested paths, so flatten the filename
    const filename = file.path.replace(/\//g, '_').replace(/^_/, '')
    gistFiles[filename] = { content: file.content }
  }
  
  return gistFiles
}
