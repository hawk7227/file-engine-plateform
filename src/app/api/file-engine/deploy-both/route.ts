/**
 * FILE ENGINE - Deploy Both (Vercel + GitHub) API Route
 * 
 * POST /api/file-engine/deploy-both
 * 
 * Deploys to both Vercel and GitHub in a single operation.
 */

import { NextRequest, NextResponse } from 'next/server';
import { BRAND_NAME } from '@/lib/brand'
import { 
  createProductionDeployment, 
  waitForDeployment 
} from '@/lib/file-engine/vercel-api';
import { 
  createRepoAndPush, 
  pushFiles, 
  checkRepoExists,
  getCurrentUser
} from '@/lib/file-engine/github-api';
import { supabase } from '@/lib/supabase';

// ============================================
// TYPES
// ============================================

interface DeployBothRequest {
  files: Array<{
    path: string;
    content: string;
  }>;
  projectName: string;
  github: {
    repoOwner?: string;
    repoName?: string;
    branch?: string;
  };
  vercel: {
    production?: boolean;
    linkToGithub?: boolean;
  };
  githubToken?: string;
  vercelToken?: string;
}

// ============================================
// ROUTE HANDLER
// ============================================

export async function POST(request: NextRequest) {
  try {
    const body: DeployBothRequest = await request.json();
    
    // Validate request
    if (!body.files || !Array.isArray(body.files) || body.files.length === 0) {
      return NextResponse.json(
        { success: false, error: 'No files provided' },
        { status: 400 }
      );
    }

    if (!body.projectName || typeof body.projectName !== 'string') {
      return NextResponse.json(
        { success: false, error: 'Project name is required' },
        { status: 400 }
      );
    }

    // Check file size limit (10MB total)
    const totalSize = body.files.reduce((acc, f) => acc + f.content.length, 0);
    if (totalSize > 10 * 1024 * 1024) {
      return NextResponse.json(
        { success: false, error: 'Total file size exceeds 10MB limit' },
        { status: 400 }
      );
    }

    // Get tokens
    const githubToken = body.githubToken || 
                       process.env.GITHUB_TOKEN || 
                       process.env.ADMIN_GITHUB_TOKEN;
    
    const vercelToken = body.vercelToken || 
                       process.env.VERCEL_TOKEN || 
                       process.env.ADMIN_VERCEL_TOKEN;

    if (!githubToken) {
      return NextResponse.json(
        { success: false, error: 'GitHub token not configured' },
        { status: 500 }
      );
    }

    if (!vercelToken) {
      return NextResponse.json(
        { success: false, error: 'Vercel token not configured' },
        { status: 500 }
      );
    }

    // Get GitHub owner
    let owner = body.github.repoOwner;
    if (!owner) {
      const user = await getCurrentUser({ token: githubToken });
      if (!user) {
        return NextResponse.json(
          { success: false, error: 'Could not determine GitHub username' },
          { status: 400 }
        );
      }
      owner = user.login;
    }

    // Sanitize names
    const sanitizedProjectName = body.projectName
      .toLowerCase()
      .replace(/\s+/g, '-')
      .replace(/[^a-z0-9-]/g, '')
      .slice(0, 50);

    const repoName = body.github.repoName || sanitizedProjectName;
    const sanitizedRepoName = repoName
      .toLowerCase()
      .replace(/\s+/g, '-')
      .replace(/[^a-z0-9-]/g, '')
      .slice(0, 100);

    // Results object
    const results: {
      success: boolean;
      github?: {
        repoUrl: string;
        commitSha?: string;
        created?: boolean;
      };
      vercel?: {
        url: string;
        deploymentId: string;
        linkedToGithub?: boolean;
      };
      error?: string;
    } = { success: false };

    // ========================================
    // STEP 1: Push to GitHub
    // ========================================
    
    const repoExists = await checkRepoExists(owner, sanitizedRepoName, { token: githubToken });
    
    let githubResult;
    if (repoExists) {
      githubResult = await pushFiles(owner, sanitizedRepoName, body.files, {
        branch: body.github.branch,
        commitMessage: `Update from ${BRAND_NAME}`,
        token: githubToken
      });
      
      if (githubResult.success) {
        results.github = {
          repoUrl: `https://github.com/${owner}/${sanitizedRepoName}`,
          commitSha: githubResult.commitSha,
          created: false
        };
      }
    } else {
      githubResult = await createRepoAndPush(sanitizedRepoName, body.files, {
        description: `Generated by ${BRAND_NAME}`,
        private: false,
        commitMessage: `Initial commit from ${BRAND_NAME}`,
        token: githubToken
      });
      
      if (githubResult.success) {
        results.github = {
          repoUrl: githubResult.repoUrl!,
          commitSha: githubResult.commitSha,
          created: true
        };
      }
    }

    if (!githubResult?.success) {
      return NextResponse.json({
        success: false,
        error: `GitHub push failed: ${githubResult?.error || 'Unknown error'}`,
        github: null,
        vercel: null
      }, { status: 422 });
    }

    // ========================================
    // STEP 2: Deploy to Vercel
    // ========================================
    
    const vercelDeployResult = await createProductionDeployment(body.files, {
      projectName: sanitizedProjectName,
      token: vercelToken,
      teamId: process.env.VERCEL_TEAM_ID
    });

    if (!vercelDeployResult.success) {
      // GitHub succeeded but Vercel failed
      return NextResponse.json({
        success: false,
        error: `Vercel deployment failed: ${vercelDeployResult.error}`,
        github: results.github,
        vercel: null
      }, { status: 422 });
    }

    // Wait for Vercel deployment
    const vercelStatus = await waitForDeployment(vercelDeployResult.deploymentId, {
      token: vercelToken,
      maxAttempts: 90
    });

    if (vercelStatus.status === 'ready') {
      results.vercel = {
        url: vercelStatus.url || vercelDeployResult.url,
        deploymentId: vercelDeployResult.deploymentId,
        linkedToGithub: body.vercel.linkToGithub
      };
      results.success = true;
    } else {
      // GitHub succeeded but Vercel build failed
      return NextResponse.json({
        success: false,
        error: `Vercel build failed: ${vercelStatus.error}`,
        github: results.github,
        vercel: null
      }, { status: 422 });
    }

    // ========================================
    // STEP 3: Save deployment record
    // ========================================
    
    const { data: { session } } = await supabase.auth.getSession();
    const userId = session?.user?.id;

    if (userId) {
      await supabase.from('file_engine_deployments').insert({
        user_id: userId,
        project_name: body.projectName,
        files: body.files,
        deployed_to: ['vercel', 'github'],
        vercel_url: results.vercel?.url,
        github_url: results.github?.repoUrl
      });
    }

    return NextResponse.json(results);

  } catch (error) {
    console.error('Deploy both error:', error);
    return NextResponse.json(
      { 
        success: false, 
        error: error instanceof Error ? error.message : 'Internal server error',
        github: null,
        vercel: null
      },
      { status: 500 }
    );
  }
}
